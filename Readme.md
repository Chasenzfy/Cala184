# **葫芦娃大战妖精**

## 游戏内容
### 游戏介绍
本游戏为葫芦娃和妖精的**弹幕闯关**游戏，默认情况下双方都由电脑自动控制，玩家也可以控制爷爷进行战斗。每个单位的弹幕速度，伤害和图形都不相同，他们将以一定的频率进行移动和弹幕射击。

游戏有4个bgm，分别在准备界面和难度1,2,3的战斗中播放。通过上一难度后继续点击开始游戏将会进行下一难度的游戏。战斗结束后将会有弹窗显示战斗结果。难度越高，敌人弹幕伤害越高，速度越快。

每个单位的生命值将会在其图片上方显示。

下面分别是难度1自动战斗和难度3手动战斗的动态图。

gif1 gif2 here
### ui介绍
image3 here

整个界面中，左侧为战场，右侧为功能按钮。

点击开始键，将会开始一场新的战斗。

点击结束建，当前的战斗或读取记录的过程结束。

两个选择栏可以分别选择妖怪和葫芦娃的阵型。（分别给了三个阵型以供选择）战斗开始时的阵型是由此决定的。

点击读取记录将会弹出选择文件的视窗，该视窗的默认位置为jar文件所在的文件夹。从文件中选择文件名形如 年@月@日@时@分@秒.xml的文件，即可开始读取这次战斗的过程。

速度栏显示了当前的战斗速度，包括每个单位的移动间隔，弹幕飞行速度等。点击加速和减速键，将会使的速度在1.0~8.0之间改变，默认速度为4.0.
### 快捷键介绍
可以手动点击按钮，也可以使用快捷键。为了防止误触使得战斗停止，没有设置停止的快捷键。

回车键，K：用于战斗开始

A：速度提高

S: 速度降低

L：读取文件

上下左右：控制爷爷移动

Z：控制爷爷射击弹幕

在本游戏中，若没有尝试控制爷爷，则爷爷会自动移动与攻击。反之，爷爷不会再自动行动。
## 实现总览
###多线程及其同步
程序中的线程有：每个生物，每个弹幕，刷新函数，读取函数，GUI界面。

生物线程负责发射弹幕线程，而其他线程都由GUI主导。

生物和刷新，读取函数都会改变生物的信息，他们之间进行了同步。

弹幕与刷新函数都会改变弹幕信息，他们之间进行了同步。

这里之所以要将弹幕设置为线程，是为了之后进一步实现弹幕运动的多样化，作为一个线程，它将可以实现更改自身的轨道而非一直直线前进。这样还更有利于数据的**同步和抽象化**。同时，弹幕若要实现连续的运动，它的位置应该相对于生物有更高的刷新率，线程可以轻松做到这一点。之后创建新的弹幕类继承基类，修改其运动逻辑等，即可实现更加多样的战斗。这一点对于游戏的**拓展**非常重要。
###读写的实现
将战斗记录保存在xml文件中，xml文件中将以round为单位记录acts，每一条act内部包括一个生物的行动。由于生物运动是多线程实现，且在行动之后立刻生成自己的行动信息提交给保存功能，所以保存功能在判断当前获得的信息量大于等于生物存活量时即可将这些信息作为一回合保存。

在读取时，由于没有记录生物的攻击目标，攻击目标的选择由生物当场确定。只要之前每一步都正确，生物选择的攻击对象应该也没有变化，将会攻击同样的目标。这使得记录时只要记录生物有没有攻击即可。

但是也有一个问题，虽然修改了手动操作时的记录逻辑，但是这种读取方式很多时候还是没有办法记录玩家到底做了什么，当玩家以远超其他生物的速度行动时，这种现象最为明显。
## 类的划分
####总体思路
分为生物类，ui类，弹幕类，阵型类，读写文件类和地图类几个部分。
####生物类
image4 here
生物类拥有自己的属性，包括位置，生命等。此外，每个生物都将一个Image对象作为自己的内部成员，以提高显示图片时的速度，使得读取图片只需要一次。该Image对象将在显示战场时使用。

生物类实现了Runnable接口，作为线程存在。每个生物的run函数中，将会持续进行移动，发射弹幕，保存信息的工作，直到该生物死亡或游戏停止。其中移动和保存信息的工作，每个生物做的都是一样的。

除了在run函数中使用到的函数，还包括一些返回值的函数与遭受弹幕攻击时“受到伤害”的函数。受到伤害这一点

继承Creature的类与Creature的主要不同点在于他们的弹幕发射函数，每个子类发射弹幕时的图片，速度和伤害都不相同。
####弹幕类
弹幕类中只有一个基类Bullet，类中记录了弹幕的位置，阵营，图片，大小信息。与Creature相同，弹幕在第一次生成时读取图片，之后无需重新读取。

同时，弹幕也实现了Runnable类，作为线程存在。弹幕生成时，将会得到自己的初始位置与目标位置，同时计算出他们之间的角度。这一角度将在显示弹幕形状（尤其是刀状弹幕）时起作用，它会使得刀的柄朝向发射者，刀刃朝向目标。在run函数中，弹幕将会不断地前进，并且不断地判断是否已经撞到了敌方单位。若撞到敌方单位，弹幕将会销毁自身，并且对该单位造成伤害。
####阵型类
阵型类相对于之前没有改变。

阵型类保存了阵型的名字以及除中心节点以外，其他阵型节点的位置信息。在类中初始化了8个阵型的信息。
####地图类

Map类内部生成了一个全局共享的20*20的地图方阵，实现了将某个坐标设置为某个生物的功能和输出全图信息的功能。

Map类相比之前实现的新功能为：返回距离某坐标点最近的生物坐标。
####全局类
Global类保存了一些全局变量，方便使用，避免矛盾。

添加了新的全局变量，包括弹幕伤害和速度的基准值等，以做到只需修改此处变量值即可改变程序表现。

同时，全局类中实现了对地图，生物和阵型的初始化。
####ui类
ui类包括两个部分，一个是Main类，作为整个程序的入口，实现读取窗口信息，显示窗口的功能。同样的，为了使得关闭窗口后所有线程停止，其中实现了一个setOnCloseRequest函数，用于在关闭程序时停止所有线程。

另一个类为窗口的控制器类，该控制器起到了连接所有代码的功能。

控制器类的`initialize()`函数将在Main打开界面时被调用，它将会开始播放背景音乐，完成所有初始化函数的调用。同时在其内部将会启动一个线程`FormCheck()`。

FormCheck类是控制器的内部类，其实现了Runnable接口，它实现的主要功能为检查对阵容的选择，并且在改变阵容后将这一改变显示在战场上。

点击开始按钮或使用快捷键将会启用`getStart()`函数,它将会完成切换背景音乐，确定生物的位置，启动刷新界面的线程，创建新的记录文件，启动所有生物的线程的工作。

若不是第一次启用`getStart()`函数，将会调用`getEnd()`函数，同样的，点击结束按钮也会调用这一函数。在这一函数中，将会将所有当前程序中的线程中断，初始化线程池，初始化变量。

点击读取文件按钮或使用快捷键后，将会调用`readFile()`函数，该函数会弹出一个选择文件的窗口，弹出窗口的默认位置是jar包所在的文件夹，这同样也是保存的记录文件的默认位置。选择文件后，将会调用`getEnd()`函数进行初始化，并且开始播放战斗记录。

读取战斗记录时使用的图像刷新函数与进行战斗时的不同。他们同样刷新图像，但是读取战斗信息时将不会尝试进行文件的保存工作和对战斗是否结束的判断工作。

点击加速，减速与使用快捷键将会改变一个全局变量`myspeed`,该全局变量将会控制所有线程完成工作期间的休息时间，并且以此控制整个游戏的进行速度。

实现了对键盘时间的读取类`myKeyBoard(KeyEvent event)`，该函数将会接受键盘信息，并且进行相应的动作。

图像的生成函数包括两个部分:显示生物图像和显示弹幕图像。他们都会与其他线程进行交互，以保证不会在其他线程尝试修改文件和弹幕信息时读取他们的信息。图像共分3个图层，最底层为背景（草地），第二层为基于Map中信息矩阵的生物图像，第三层为弹幕图像。

生物图像由两个部分组成：代表生命值剩余量的血条和代表生物的图片。由于每个生物仅有25*25大小，但是都有100生命值，对于生命值的显示没有做到精确到每一点。

弹幕图像的生成基于三个信息：图像，位置和角度。它们保存在每个弹幕的内部，其中角度的存在使得非中心对称的弹幕将会朝着目标直线飞去，这一点尤其表现在爷爷和蛇精的弹幕上（都为刀状图片，分别为蓝色和红色）

####读写文件类
读写文件类主要实现了读写战斗记录的功能。其中包括两个类：Act类用于记录每一条战斗信息，MyJdom类用于读写xml文件。

Act类中将战斗信息分为5个部分：哪个生物 做了什么 是否或者 横纵坐标。该类由生物行动之后自己生成。并且打包提交给ui类。ui类判定一轮结束后，就会将这一轮信息写入xml文件。

MyJdom类包含三个函数：

createRoot(String filename)用于生成对应文件名的根信息。

writeXML(String filename, ArrayList<Act> acts)将一组act写入文件之中。

readXML(String filename)将读取文件中的战斗信息，并且与ui类交互，每读取一组信息，ui将会刷新战斗画面，以重现战斗。

同时MyJdom类实现了Runnable接口，目的是读取信息时对生物信息的修改与ui读取信息不会同时进行。其run函数内只有一行代码，即调用readXML函数。

值得一提的是，由于对爷爷的控制战斗的完成时间晚于读写文件的时间，对进行过手动操作的游戏的记录将不会与原来的过程完全一样。对爷爷的操作越快，不同将会越大。但同时，对没有进行过操作的文件读写没有问题。


##反思
###没有很好地使用设计模式
这一点在我相加新功能时体现的尤为明显
###代码耦合度过高
代码中充满了互相调用数据的现象，很多函数通过全局变量或对方的数据进行通信
###鲁棒性不足
我对于多线程的理解还是不够深，导致经常出现一些奇怪的问题。同样的，当前程序在输入移动信息过快时会出现卡顿问题
###代码内聚度不高
为了方便，我将很多函数写在一起，最终导致控制器类有500+行长这种情况发生。
##总结
虽然开始写代码是一个艰难的过程，但是只要已经开始，我就总想着加一些新功能。最开始是弹幕，后来我想要非原型的有方向的弹幕，之后我又想使用图片素材作为弹幕形状。诸如此类的情况很多，我尝试将我的程序变得更像一个真的游戏，它有关卡，有音乐，有难度划分，有读档等等。还有一些功能没有来的及实现，如使用技能，环境元素等。总之，虽然困难重重，但成就感也存在，同样让我有了寒假扩展游戏内容的想法。感谢老师与助教的工作。

# CALA
